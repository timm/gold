#- vim: ft=awk ts=2 sw=2 et :

-----------------------------------------------
Tools for summarizing columns of data.
 
Copyright (c) 2020, Tim Menzies.  Licensed under the MIT license.
For full license info, see LICENSE.md in the project root

-----------------------------------------------

@include "lib"   
@include "col"

-----------------------------------------------------------

## Row 
Storage for one row of data.

function Row(i:untyped) {
  ## Constructor
  Object(i)
  i.is = "Row"
  i.P  = 2
  has(i,"cells")
  has(i,"bins") }

function _Dist(i:Row,j:Row, tab, cols,  c,pos,x,y,d,d1,n) {
  ## Distance between two rows
  n = 1E-32
  for(c in cols) {
    pos = tab.cols[c].pos
    x   = i.cells[pos]
    y   = j.cells[pos]
    d1  = (x=="?" && y=="?") ? 1 : dist(tab.cols[c], x,y)
    d  += d1^i.P
    n++ }
  return (d/n)^(1/i.P) }

-----------------------------------------------------------

## Rows 
Storage for many rows of data, with summaries of the columns.
The first row passed to `Rows` initializes the column summary objects.
The other rows are data.  In that first row:

- Column names containing `?` become `Info` columns.
- Column names containing `<>:` are `Num`bers (and all others are `Sym`s).
- Dependent variables (stored in `ys`) are marked with `<>!` 
  and all other are independent variables (stored in `xs`).
- Klass names are marked in `!`.

function Rows(i:untyped, a:array|) {
  ## Constructor
  Object(i); i.is = "Rows"
 i.klass   = ""
  i.use     = "xs"
  i.far     = .95
  i.arounds = 128
  has(i,"rows");  has(i,"cols"); has(i,"names")
  has(i, "nums"); has(i, "syms")
  has(i,"info");  has(i,"xs");   has(i,"ys") 
  if (length(a)) _Add(i,a)}

function _Load(i:Rows, f:fname,     record) {
  ## Load a csv file `f` into the table `i`
  while(csv(record,f)) {  add(i,record)} }

function _Add(i:Rows, a:array) {
  ## Update `i` with `a`. First update creates the column headers.
  if ("cells" in a) return RowsAdd(i, a.cells)
  return length(i.cols) ?  RowsData(i,a) : RowsHeader(i,a) }

function _Header(i,a,   where, what, j) {
  ## Initialize columns in a table.
  for(j=1; j<=length(a); j++) {
    i.names[j] = a[j]
    if (a[j] ~ /\?/) {
      what="Info"
      where="info"
    } else {
      what = a[j] ~ /[:<>]/ ?  "Num" : "Sym"
      where= a[j] ~ /[!<>]/ ?  "ys"  : "xs"
    }
    hAS(i.cols, j, what, a[j],j)   
    what == "Num" ? i.nums[j] : i.syms[j]
    i[where][j]
    if (a[j]~/!/) i.klass = j }
  return 0}

function _Data(i:Rows, a:array,    r,j) {
  ## Add an row at some random index within `rows`.
  r = sprintf("%9.0f",1E9*rand())
  has(i.rows, r, "Row")
  for(j=1; j<=length(a); j++) 
    i.rows[r].bins[j] = i.rows[r].cells[j] = add(i.cols[j], a[j])  
  return r }

function _Dist(i:Rows, r1:posint, r2:posint) {
  ## Distance between two rows.
  return  RowDist(i.rows[r1], i.rows[r2], i,i[i.use]) }

function _Far(i:Rows, r:posint,     n,out) {
  ## Return something quite far way from `r` (ignoring outliers).
  n= _Around(i,r, out) 
  return out[int(n*i.far)].row }

function _Around(i,r1,out,   r2,n) {
  ## Compute `out`; i.e.  pairs <row,d> listing neighbors of `r1`.
  ## Sorted by distance `d`.
  n = i.arounds 
  for(r2 in i.rows) 
    if(r1 != r2) {
       if(--n<0) break
       out[r2].row = r2
       out[r2].d   = _Dist(i,r1, r2) }
  return keysort(out,"d") }

function _Clone(i:Rows, j:Rows) {
  ## Copy the structure of table `i` into a new table `j`.
  Rows(j)
  RowsHeader(j, i.names) }

function _Y(i:Rows,   c,s,sep) {
  for(c in i.ys) { 
    s = s sep i.cols[c].txt "=" i.cols[c].mu
    sep = ", " }
  return s }

function _Sample(i:Rows,a:untyped,c:posint,n:posint|128, r,v) {
  ## Set `a` to a sample of `enough` rows from column `c`.
  ## Avoid cells with empty values
  n = n ? n : 128
  for(r in i.rows) {
    v = i.rows[r].cells[c]
    if(v != "?") {
      if(--n>0) {a[r] = v} else {break}}}}

function _Bins(i:Rows,   n) {
  ## Discretize all numeric columns in each row's `bins`.
  for(n in i.nums) 
    if (n in i.xs) 
      _Bin(i,n) }

function _Bin(i:Rows,n:posint,   tmp,r,a,bins) {
  ## Discretize one column of numeric values in each row's `bins`.
  _Sample(i,a,n)
  div(a,bins)
  for(r in i.rows)  
    i.rows[r].bins[n] = bin(bins, i.rows[r].bins[n]) }

function _BinsHeader(i:Rows, out:untyped,      col) {
  ## Return a header where all the independent columns are not numbers
  for(col in i.cols) {
    out[col] = i.cols[col].txt
    if (col in i.xs) gsub(/:/,"",out[col] ) }}

function _SomeBins(i:Rows,a:array,out:array,    n,head,r) {
  ## Add a new table to `out` with discretized values for some rows. 
  n = new(out,"Rows")
  RowsBinsHeader(i,  head)
  RowsHeader(out[n], head)
  for(r in a) 
    RowsData(out[n], i.rows[r].bins) 
  return n }
